// Code generated by hertz generator.

package api

import (
	"context"
	"errors"
	"fmt"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	hertzconsts "github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/keycasiter/3g_game/biz/consts"
	"github.com/keycasiter/3g_game/biz/dal/cache"
	"github.com/keycasiter/3g_game/biz/dal/mysql"
	"github.com/keycasiter/3g_game/biz/logic/battle"
	api "github.com/keycasiter/3g_game/biz/model/api"
	"github.com/keycasiter/3g_game/biz/model/common"
	"github.com/keycasiter/3g_game/biz/model/enum"
	"github.com/keycasiter/3g_game/biz/model/po"
	"github.com/keycasiter/3g_game/biz/model/vo"
	"github.com/keycasiter/3g_game/biz/tactics/model"
	"github.com/keycasiter/3g_game/biz/util"
	"github.com/spf13/cast"
)

// @title 三战配将侯小程序
// @version 1.0
// @description 三战配将侯小程序

// @contact.name 3g_game
// @contact.url keycasiter@qq.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host 3game.tech
// @BasePath /
// @schemes http

// BattleDo @Summary 发起模拟对战
// @Description 发起模拟对战
// @Tags 模拟对战
// @Accept json
// @Produce json
// @@Success 0
// @Failure
// @Router /v1/battle/do [POST]
func BattleDo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.BattleDoRequest
	resp := new(api.BattleDoResponse)
	resp.Meta = util.BuildSuccMeta()

	err = c.BindAndValidate(&req)
	//日志打印
	hlog.CtxInfof(ctx, "BattleExecute Req:%s", util.ToJsonString(ctx, req))

	if err != nil {
		hlog.CtxErrorf(ctx, "BattleLogicContext Run Err:%v", err)
		resp.Meta = util.BuildFailMetaWithMsg("未知错误")
		c.JSON(hertzconsts.StatusOK, resp)
		return
	}

	//参数校验
	if err := checkParam(req); err != nil {
		hlog.CtxWarnf(ctx, "BattleLogicContext Param Err:%v", err)
		resp.Meta = util.BuildFailMetaWithMsg("未知错误")
		c.JSON(hertzconsts.StatusOK, resp)
		return
	}

	//逻辑执行
	serviceResp, err := battle.NewBattleLogicV2Context(ctx, buildBattleDoRequest(ctx, req)).Run()
	if err != nil {
		hlog.CtxErrorf(ctx, "BattleLogicContext Run Err:%v", err)
		resp.Meta = util.BuildFailMetaWithMsg("未知错误")
		c.JSON(hertzconsts.StatusOK, resp)
		return
	}

	//组合resp
	//copier.Copy(resp, serviceResp)
	buildResponse(resp, serviceResp)

	c.JSON(hertzconsts.StatusOK, resp)
	//日志打印
	//jsonStr, _ := jsoniter.Marshal(resp)
	//pretty.Logf("resp:【%s】", jsonStr)

	defer func() {
		err := mysql.NewUserBattleRecord().CreateUserBattleRecord(ctx, &po.UserBattleRecord{
			Uid:          req.Uid,
			BattleParam:  util.ToJsonString(ctx, req),
			BattleRecord: util.ToJsonString(ctx, resp),
		})
		if err != nil {
			hlog.CtxErrorf(ctx, "CreateUserBattleRecord err:%v", err)
			//ignore 不阻塞对战流程
		}
	}()
}

func buildResponse(resp *api.BattleDoResponse, serviceResp *battle.BattleLogicV2ContextResponse) {
	resp.Meta = &common.Meta{
		StatusCode: enum.ResponseCode_Success,
		StatusMsg:  "成功",
	}
	//组合过程数据
	resp.BattleProcessStatistics = makeBattleProcessStatistics(serviceResp)
	//组合统计数据
	resp.BattleResultStatistics = makeBattleResultStatistics(serviceResp)
}

// 战报数据
func makeBattleProcessStatistics(serviceResp *battle.BattleLogicV2ContextResponse) map[int64]map[int64][]string {
	battleProcessStatistics := make(map[int64]map[int64][]string, 0)
	for battlePhase, battleRoundStatisticsMap := range serviceResp.BattleProcessStatistics {
		m := make(map[int64][]string, 0)
		for round, strings := range battleRoundStatisticsMap {
			m[cast.ToInt64(round)] = strings
		}
		battleProcessStatistics[int64(battlePhase)] = m
	}
	return battleProcessStatistics
}

// 对战统计数据
func makeBattleResultStatistics(serviceResp *battle.BattleLogicV2ContextResponse) *api.BattleResultStatistics {
	return &api.BattleResultStatistics{
		//我军
		FightingTeam: &api.TeamBattleStatistics{
			BattleTeam: &api.BattleTeamStatistics{
				TeamType:              enum.TeamType(serviceResp.BattleResultStatistics.FightingTeam.BattleTeam.TeamType),
				ArmType:               enum.ArmType(serviceResp.BattleResultStatistics.FightingTeam.BattleTeam.ArmType),
				BattleGenerals:        makeBattleGenerals(serviceResp.BattleResultStatistics.FightingTeam),
				SoliderNum:            makeSoliderNum(serviceResp.BattleResultStatistics.FightingTeam.BattleTeam.BattleGenerals),
				RemainNum:             makeRemainNum(serviceResp.BattleResultStatistics.FightingTeam.BattleTeam.BattleGenerals),
				KillSoliderNum:        makeKillSoliderNum(serviceResp.BattleResultStatistics.FightingTeam.GeneralBattleStatisticsList),
				ResumeSoliderNum:      makeResumeSoliderNum(serviceResp.BattleResultStatistics.FightingTeam.GeneralBattleStatisticsList),
				RoundKillSoliderNum:   makeRoundKillSolider(serviceResp.BattleResultStatistics.FightingTeam.GeneralBattleStatisticsList),
				RoundResumeSoliderNum: makeRoundResumeSolider(serviceResp.BattleResultStatistics.FightingTeam.GeneralBattleStatisticsList),
				RoundRemainSoliderNum: makeRoundRemainSolider(serviceResp.BattleResultStatistics.FightingTeam.GeneralBattleStatisticsList),
			},
			BattleResult: enum.BattleResult(serviceResp.BattleResultStatistics.FightingTeam.BattleResult),
		},
		//敌军
		EnemyTeam: &api.TeamBattleStatistics{
			BattleTeam: &api.BattleTeamStatistics{
				TeamType:              enum.TeamType(serviceResp.BattleResultStatistics.EnemyTeam.BattleTeam.TeamType),
				ArmType:               enum.ArmType(serviceResp.BattleResultStatistics.EnemyTeam.BattleTeam.ArmType),
				BattleGenerals:        makeBattleGenerals(serviceResp.BattleResultStatistics.EnemyTeam),
				SoliderNum:            makeSoliderNum(serviceResp.BattleResultStatistics.EnemyTeam.BattleTeam.BattleGenerals),
				RemainNum:             makeRemainNum(serviceResp.BattleResultStatistics.EnemyTeam.BattleTeam.BattleGenerals),
				KillSoliderNum:        makeKillSoliderNum(serviceResp.BattleResultStatistics.EnemyTeam.GeneralBattleStatisticsList),
				ResumeSoliderNum:      makeResumeSoliderNum(serviceResp.BattleResultStatistics.EnemyTeam.GeneralBattleStatisticsList),
				RoundKillSoliderNum:   makeRoundKillSolider(serviceResp.BattleResultStatistics.EnemyTeam.GeneralBattleStatisticsList),
				RoundResumeSoliderNum: makeRoundResumeSolider(serviceResp.BattleResultStatistics.EnemyTeam.GeneralBattleStatisticsList),
				RoundRemainSoliderNum: makeRoundRemainSolider(serviceResp.BattleResultStatistics.EnemyTeam.GeneralBattleStatisticsList),
			},
			BattleResult: enum.BattleResult(serviceResp.BattleResultStatistics.EnemyTeam.BattleResult),
		},
	}
}

func makeRoundRemainSolider(battleGenerals []*model.GeneralBattleStatistics) map[enum.BattlePhase]map[enum.BattleRound]int64 {
	resultMap := make(map[enum.BattlePhase]map[enum.BattleRound]int64, 0)
	for _, general := range battleGenerals {
		//单独一个武将的每一个回合
		//剩余兵力
		for phase, battleRound2CntMap := range general.RoundRemainSoliderNum {
			if battleRound2CntMapOld, ok := resultMap[enum.BattlePhase(phase)]; ok {
				for round, cnt := range battleRound2CntMap {
					oldCnt, _ := battleRound2CntMapOld[enum.BattleRound(round)]
					battleRound2CntMapOld[enum.BattleRound(round)] = cnt + oldCnt
				}
				resultMap[enum.BattlePhase(phase)] = battleRound2CntMapOld
			} else {
				battleRound2CntMapNew := make(map[enum.BattleRound]int64, 0)
				for round, cnt := range battleRound2CntMap {
					battleRound2CntMapNew[enum.BattleRound(round)] = cnt
				}
				resultMap[enum.BattlePhase(phase)] = battleRound2CntMapNew
			}
		}
	}

	return resultMap
}

func makeRoundResumeSolider(battleGenerals []*model.GeneralBattleStatistics) map[enum.BattlePhase]map[enum.BattleRound]int64 {
	resultMap := make(map[enum.BattlePhase]map[enum.BattleRound]int64, 0)
	for _, general := range battleGenerals {
		//单独一个武将的每一个回合
		//恢复
		for _, tacticStatistic := range general.TacticStatisticsList {
			for phase, round2CntMapNew := range tacticStatistic.RoundResumeSoliderNum {
				//准备/对战阶段
				if round2CntMapOld, ok := resultMap[enum.BattlePhase(phase)]; ok {
					for round, cntNew := range round2CntMapNew {
						//存在则累计
						if cntOld, okk := round2CntMapOld[enum.BattleRound(round)]; okk {
							round2CntMapOld[enum.BattleRound(round)] = cntOld + cntNew
						} else {
							//不存在则新存入
							round2CntMapOld[enum.BattleRound(round)] = cntNew
						}
					}
				} else {
					//没有新对战阶段
					newM := make(map[enum.BattleRound]int64, 0)
					for round, cnt := range round2CntMapNew {
						newM[enum.BattleRound(round)] = cnt
					}
					resultMap[enum.BattlePhase(phase)] = newM
				}
			}
		}
	}

	return resultMap
}

func makeRoundKillSolider(battleGenerals []*model.GeneralBattleStatistics) map[enum.BattlePhase]map[enum.BattleRound]int64 {
	resultMap := make(map[enum.BattlePhase]map[enum.BattleRound]int64, 0)
	for _, general := range battleGenerals {
		//单独一个武将的每一个回合
		//1.普攻
		for phase, round2CntMapNew := range general.GeneralAttackStatistics.RoundKillSoliderNum {
			//准备/对战阶段
			if round2CntMapOld, ok := resultMap[enum.BattlePhase(phase)]; ok {
				for round, cntNew := range round2CntMapNew {
					//存在则累计
					if cntOld, okk := round2CntMapOld[enum.BattleRound(round)]; okk {
						round2CntMapOld[enum.BattleRound(round)] = cntOld + cntNew
					} else {
						//不存在则新存入
						round2CntMapOld[enum.BattleRound(round)] = cntNew
					}
				}
			} else {
				//没有新对战阶段
				newM := make(map[enum.BattleRound]int64, 0)
				for round, cnt := range round2CntMapNew {
					newM[enum.BattleRound(round)] = cnt
				}
				resultMap[enum.BattlePhase(phase)] = newM
			}
		}
		//2. 战法
		for _, tacticStatistic := range general.TacticStatisticsList {
			for phase, round2CntMapNew := range tacticStatistic.RoundKillSoliderNum {
				//准备/对战阶段
				if round2CntMapOld, ok := resultMap[enum.BattlePhase(phase)]; ok {
					for round, cntNew := range round2CntMapNew {
						//存在则累计
						if cntOld, okk := round2CntMapOld[enum.BattleRound(round)]; okk {
							round2CntMapOld[enum.BattleRound(round)] = cntOld + cntNew
						} else {
							//不存在则新存入
							round2CntMapOld[enum.BattleRound(round)] = cntNew
						}
					}
				} else {
					//没有新对战阶段
					newM := make(map[enum.BattleRound]int64, 0)
					for round, cnt := range round2CntMapNew {
						newM[enum.BattleRound(round)] = cnt
					}
					resultMap[enum.BattlePhase(phase)] = newM
				}
			}
		}
	}
	return resultMap
}

func makeGeneralBattleStatistics(statisticsList []*model.GeneralBattleStatistics, idx int) *api.GeneralBattleStatistics {
	result := &api.GeneralBattleStatistics{}

	statistics := statisticsList[idx]
	tacticStatisticsList := make([]*api.TacticStatistics, 0)
	//战法统计
	for _, tacticStatistics := range statistics.TacticStatisticsList {
		tacticStatisticsList = append(tacticStatisticsList, &api.TacticStatistics{
			TacticId:              tacticStatistics.TacticId,
			TacticName:            tacticStatistics.TacticName,
			TacticQuality:         tacticStatistics.TacticQuality,
			TriggerTimes:          tacticStatistics.TriggerTimes,
			KillSoliderNum:        tacticStatistics.KillSoliderNum,
			ResumeSoliderNum:      tacticStatistics.ResumeSoliderNum,
			RoundTriggerTimes:     buildRoundStatistics(tacticStatistics.RoundTriggerTimes),
			RoundKillSoliderNum:   buildRoundStatistics(tacticStatistics.RoundKillSoliderNum),
			RoundResumeSoliderNum: buildRoundStatistics(tacticStatistics.RoundResumeSoliderNum),
		})
	}
	//普攻
	attackStatistics := &api.TacticStatistics{
		TriggerTimes:     statistics.GeneralAttackStatistics.TriggerTimes,
		KillSoliderNum:   statistics.GeneralAttackStatistics.KillSoliderNum,
		ResumeSoliderNum: statistics.GeneralAttackStatistics.ResumeSoliderNum,
	}

	result.TacticStatisticsList = tacticStatisticsList
	result.GeneralAttackStatistics = attackStatistics

	return result
}

func buildRoundStatistics(m map[consts.BattlePhase]map[consts.BattleRound]int64) map[enum.BattlePhase]map[enum.BattleRound]int64 {
	resultMap := make(map[enum.BattlePhase]map[enum.BattleRound]int64, 0)

	if len(m) == 0 {
		return resultMap
	}

	for battlePhase, battleRound2TimesMap := range m {
		if len(battleRound2TimesMap) == 0 {
			continue
		}
		newMM := make(map[enum.BattleRound]int64, 0)
		for k, v := range battleRound2TimesMap {
			newMM[enum.BattleRound(k)] = v
		}
		resultMap[enum.BattlePhase(battlePhase)] = newMM
	}

	return resultMap
}

func makeSoliderNum(battleGenerals []*vo.BattleGeneral) int64 {
	teamSoliderNum := int64(0)
	for _, general := range battleGenerals {
		teamSoliderNum += general.InitSoldierNum
	}
	return teamSoliderNum
}

func makeRemainNum(battleGenerals []*vo.BattleGeneral) int64 {
	teamRemainNum := int64(0)
	for _, general := range battleGenerals {
		teamRemainNum += general.SoldierNum
	}
	return teamRemainNum
}

func makeKillSoliderNum(battleGenerals []*model.GeneralBattleStatistics) int64 {
	teamKillSoliderNum := int64(0)
	for _, general := range battleGenerals {
		//战法
		for _, statistics := range general.TacticStatisticsList {
			teamKillSoliderNum += statistics.KillSoliderNum
		}
		//普攻
		teamKillSoliderNum += general.GeneralAttackStatistics.KillSoliderNum
	}
	return teamKillSoliderNum
}

func makeResumeSoliderNum(battleGenerals []*model.GeneralBattleStatistics) int64 {
	teamResumeSoliderNum := int64(0)
	for _, general := range battleGenerals {
		//战法
		for _, statistics := range general.TacticStatisticsList {
			teamResumeSoliderNum += statistics.ResumeSoliderNum
		}
		//普攻
		teamResumeSoliderNum += general.GeneralAttackStatistics.ResumeSoliderNum
	}
	return teamResumeSoliderNum
}

func makeBattleGenerals(teamBattleStatistics *model.TeamBattleStatistics) []*api.BattleGeneralStatistics {
	resList := make([]*api.BattleGeneralStatistics, 0)

	generalStatisticsList := teamBattleStatistics.GeneralBattleStatisticsList
	for idx, general := range teamBattleStatistics.BattleTeam.BattleGenerals {
		resList = append(resList, &api.BattleGeneralStatistics{
			BaseInfo: &api.MetadataGeneral{
				Id:          general.BaseInfo.Id,
				Name:        general.BaseInfo.Name,
				Group:       enum.Group(general.BaseInfo.Group),
				GeneralTag:  makeGeneralTag(general.BaseInfo.GeneralTag),
				AvatarUrl:   general.BaseInfo.AvatarUri,
				AbilityAttr: makeAbilityAttr(general),
				ArmsAttr:    makeArmsAttr(general),
			},
			IsMaster:                       general.IsMaster,
			SoldierNum:                     general.InitSoldierNum,
			RemainNum:                      general.SoldierNum,
			KillSoliderNum:                 makeGeneralKillSoliderNum(generalStatisticsList[idx]),
			ResumeSoliderNum:               makeGeneralResumeSoliderNum(generalStatisticsList[idx]),
			RoundRemainSoliderNum:          makeGeneralRoundMap(generalStatisticsList[idx].RoundRemainSoliderNum),
			RoundKillSoliderNum:            makeGeneralRoundMap(generalStatisticsList[idx].RoundKillSoliderNum),
			RoundResumeSoliderNum:          makeGeneralRoundMap(generalStatisticsList[idx].RoundResumeSoliderNum),
			RoundTacticKillSoliderNum:      makeGeneralRoundMap(generalStatisticsList[idx].RoundTacticKillSoliderNum),
			RoundAttackKillSoliderNum:      makeGeneralRoundMap(generalStatisticsList[idx].RoundAttackKillSoliderNum),
			BuffEffectHolderMap:            makeBuffEffectHolderMap(general.BuffEffectHolderMap),
			DeBuffEffectHolderMap:          makeDeBuffEffectHolderMap(general.DeBuffEffectHolderMap),
			BuffEffectCountMap:             makeBuffEffectCountMap(general.BuffEffectCountMap),
			DeBuffEffectCountMap:           makeDeBuffEffectCountMap(general.DeBuffEffectCountMap),
			ExecuteGeneralAttackNum:        general.ExecuteGeneralAttackNum,
			SufferExecuteGeneralAttackNum:  general.SufferExecuteGeneralAttackNum,
			ExecuteWeaponAttackNum:         general.ExecuteWeaponAttackNum,
			ExecuteStrategyAttackNum:       general.ExecuteStrategyAttackNum,
			SufferExecuteWeaponAttackNum:   general.SufferExecuteWeaponAttackNum,
			SufferExecuteStrategyAttackNum: general.SufferExecuteStrategyAttackNum,
			GeneralBattleStatistics:        makeGeneralBattleStatistics(teamBattleStatistics.GeneralBattleStatisticsList, idx),
		})
	}
	return resList
}

func makeBuffEffectCountMap(m map[consts.BuffEffectType]int64) map[string]int64 {
	resultMap := make(map[string]int64, 0)
	for k, v := range m {
		resultMap[k.String()] = v
	}
	return resultMap
}

func makeDeBuffEffectCountMap(m map[consts.DebuffEffectType]int64) map[string]int64 {
	resultMap := make(map[string]int64, 0)
	for k, v := range m {
		resultMap[k.String()] = v
	}
	return resultMap
}

func makeBuffEffectHolderMap(BuffEffectHolderMap map[consts.BuffEffectType][]*vo.EffectHolderParams) map[string][]*api.EffectHolderParams {
	resultMap := make(map[string][]*api.EffectHolderParams, 0)
	for effectType, params := range BuffEffectHolderMap {
		newArr := make([]*api.EffectHolderParams, 0)
		for _, param := range params {
			newArr = append(newArr, &api.EffectHolderParams{
				TriggerRate:      param.TriggerRate,
				EffectValue:      param.EffectValue,
				EffectRate:       param.EffectRate,
				EffectRound:      enum.BattleRound(param.EffectRound),
				EffectTimes:      param.EffectTimes,
				MaxEffectTimes:   param.MaxEffectTimes,
				FromTactic:       param.FromTactic.String(),
				FromWarbook:      param.FromWarbook.String(),
				IsSupportRefresh: param.IsSupportRefresh,
				IsAvoidDispel:    param.IsAvoidDispel,
			},
			)
		}
		arr, ok := resultMap[(effectType).String()]
		if ok {
			arr = append(arr, newArr...)
			resultMap[(effectType).String()] = arr
		} else { //不存在
			resultMap[(effectType).String()] = newArr
		}
	}
	return resultMap
}

func makeDeBuffEffectHolderMap(deBuffEffectHolderMap map[consts.DebuffEffectType][]*vo.EffectHolderParams) map[string][]*api.EffectHolderParams {
	resultMap := make(map[string][]*api.EffectHolderParams, 0)
	for effectType, params := range deBuffEffectHolderMap {
		newArr := make([]*api.EffectHolderParams, 0)
		for _, param := range params {
			newArr = append(newArr, &api.EffectHolderParams{
				TriggerRate:      param.TriggerRate,
				EffectValue:      param.EffectValue,
				EffectRate:       param.EffectRate,
				EffectRound:      enum.BattleRound(param.EffectRound),
				EffectTimes:      param.EffectTimes,
				MaxEffectTimes:   param.MaxEffectTimes,
				FromTactic:       param.FromTactic.String(),
				FromWarbook:      param.FromWarbook.String(),
				IsSupportRefresh: param.IsSupportRefresh,
				IsAvoidDispel:    param.IsAvoidDispel,
			},
			)
		}
		arr, ok := resultMap[effectType.String()]
		if ok {
			arr = append(arr, newArr...)
			resultMap[effectType.String()] = arr
		} else { //不存在
			resultMap[effectType.String()] = newArr
		}
	}
	return resultMap
}

func makeGeneralResumeSoliderNum(generalBattleStatistics *model.GeneralBattleStatistics) int64 {
	generalResumeNum := int64(0)
	//战法
	for _, tactic := range generalBattleStatistics.TacticStatisticsList {
		generalResumeNum += tactic.ResumeSoliderNum
	}
	//普攻
	generalResumeNum += generalBattleStatistics.GeneralAttackStatistics.ResumeSoliderNum

	return generalResumeNum
}

func makeGeneralKillSoliderNum(generalBattleStatistics *model.GeneralBattleStatistics) int64 {
	generalKillNum := int64(0)
	//战法
	for _, tactic := range generalBattleStatistics.TacticStatisticsList {
		generalKillNum += tactic.KillSoliderNum
	}
	//普攻
	generalKillNum += generalBattleStatistics.GeneralAttackStatistics.KillSoliderNum

	return generalKillNum
}

func makeGeneralRoundMap(round map[consts.BattlePhase]map[consts.BattleRound]int64) map[enum.BattlePhase]map[enum.BattleRound]int64 {
	resultMap := make(map[enum.BattlePhase]map[enum.BattleRound]int64, 0)
	for phase, round2CntMap := range round {
		if round2CntMapOld, ok := resultMap[enum.BattlePhase(phase)]; ok {
			for round, cnt := range round2CntMap {
				cntOld, _ := round2CntMapOld[enum.BattleRound(round)]
				round2CntMapOld[enum.BattleRound(round)] = cnt + cntOld
			}
		} else {
			round2CntMapNew := make(map[enum.BattleRound]int64, 0)
			for round, cnt := range round2CntMap {
				round2CntMapNew[enum.BattleRound(round)] = cnt
			}
			resultMap[enum.BattlePhase(phase)] = round2CntMapNew
		}
	}
	return resultMap
}

func makeAbilityAttr(general *vo.BattleGeneral) *api.AbilityAttr {
	return &api.AbilityAttr{
		ForceBase:        cast.ToString(general.BaseInfo.AbilityAttr.ForceBase),
		IntelligenceBase: cast.ToString(general.BaseInfo.AbilityAttr.IntelligenceBase),
		CommandBase:      cast.ToString(general.BaseInfo.AbilityAttr.CommandBase),
		SpeedBase:        cast.ToString(general.BaseInfo.AbilityAttr.SpeedBase),
	}
}

func makeArmsAttr(general *vo.BattleGeneral) *api.ArmsAttr {
	return &api.ArmsAttr{
		Cavalry:   util.ArmsAbilityToEnum(general.BaseInfo.ArmsAttr.Cavalry),
		Mauler:    util.ArmsAbilityToEnum(general.BaseInfo.ArmsAttr.Mauler),
		Archers:   util.ArmsAbilityToEnum(general.BaseInfo.ArmsAttr.Archers),
		Spearman:  util.ArmsAbilityToEnum(general.BaseInfo.ArmsAttr.Spearman),
		Apparatus: util.ArmsAbilityToEnum(general.BaseInfo.ArmsAttr.Apparatus),
	}
}

func buildBattleDoRequest(ctx context.Context, req api.BattleDoRequest) *battle.BattleLogicV2ContextRequest {
	//查询武将信息
	generalIds := make([]int64, 0)
	for _, general := range req.FightingTeam.BattleGenerals {
		generalIds = append(generalIds, general.BaseInfo.Id)
	}
	for _, general := range req.EnemyTeam.BattleGenerals {
		generalIds = append(generalIds, general.BaseInfo.Id)
	}
	//整理成map
	generalInfoMap := make(map[int64]*po.General, 0)
	for _, generalId := range generalIds {
		generalInfoMap[generalId] = cache.CacheGeneralMap[generalId]
	}

	//我方信息
	fightingTeamGenerals := make([]*vo.BattleGeneral, 0)
	for _, general := range req.FightingTeam.BattleGenerals {
		fightingTeamGenerals = buildGenerals(ctx, generalInfoMap, general, req.FightingTeam.TeamType, fightingTeamGenerals)
	}

	//敌方信息
	enemyTeamGenerals := make([]*vo.BattleGeneral, 0)
	for _, general := range req.EnemyTeam.BattleGenerals {
		enemyTeamGenerals = buildGenerals(ctx, generalInfoMap, general, req.EnemyTeam.TeamType, enemyTeamGenerals)
	}

	//组装
	serviceReq := &battle.BattleLogicV2ContextRequest{
		//我方
		FightingTeam: &vo.BattleTeam{
			TeamType:                  consts.TeamType(req.FightingTeam.TeamType),
			ArmType:                   consts.ArmType(req.FightingTeam.ArmType),
			BattleGenerals:            fightingTeamGenerals,
			BuildingTechAttrAddition:  makeBuildingTechAttrAddition(req.FightingTeam),
			BuildingTechGroupAddition: makeBuildingTechGroupAddition(req.FightingTeam),
		},
		//敌方
		EnemyTeam: &vo.BattleTeam{
			TeamType:                  consts.TeamType(req.EnemyTeam.TeamType),
			ArmType:                   consts.ArmType(req.EnemyTeam.ArmType),
			BattleGenerals:            enemyTeamGenerals,
			BuildingTechAttrAddition:  makeBuildingTechAttrAddition(req.EnemyTeam),
			BuildingTechGroupAddition: makeBuildingTechGroupAddition(req.EnemyTeam),
		},
		Uid: req.Uid,
	}
	return serviceReq
}

func buildGenerals(ctx context.Context, generalInfoMap map[int64]*po.General, general *api.BattleGeneral, teamType enum.TeamType, teamGenerals []*vo.BattleGeneral) []*vo.BattleGeneral {
	//1. 我方武将信息（从db获取）
	generalInfo := &po.General{}
	if info, ok := generalInfoMap[general.BaseInfo.Id]; ok {
		generalInfo = info
	} else {
		panic(any(fmt.Sprintf("武将信息不存在:%d", general.BaseInfo.Id)))
	}

	//2. 佩戴战法(自带战法+选择战法)
	equipTactics := make([]*po.Tactics, 0)
	//*自带战法(从db获取)
	equipTactics = append(equipTactics, &po.Tactics{
		Id:            consts.TacticId(generalInfo.SelfTacticId),
		Name:          cache.CacheTacticMap[int64(generalInfo.SelfTacticId)].Name,
		TacticsSource: consts.TacticsSource(cache.CacheTacticMap[int64(generalInfo.SelfTacticId)].Source),
		Type:          consts.TacticsType(cache.CacheTacticMap[int64(generalInfo.SelfTacticId)].Type),
	})
	//*选择战法（从参数获取）
	for _, tactic := range general.EquipTactics {
		equipTactics = append(equipTactics, &po.Tactics{
			Id:            consts.TacticId(tactic.Id),
			Name:          fmt.Sprintf("%v", consts.TacticId(tactic.Id)),
			TacticsSource: consts.TacticsSource(tactic.TacticsSource),
			Type:          consts.TacticsType(tactic.Type),
		})
	}

	//*兵书（从参数获取）
	warbooks := make([]*po.Warbook, 0)
	for _, warbook := range general.WarBooks {
		warbookCache := cache.CacheWarBookMap[warbook.Id]
		warbooks = append(warbooks, &po.Warbook{
			Id:    warbook.Id,
			Name:  fmt.Sprintf("%v", warbookCache.Name),
			Level: warbookCache.Level,
			Type:  warbookCache.Type,
			Desc:  warbookCache.Desc,
		})
	}

	//*武将信息（从db/参数获取）
	baseInfo := &po.MetadataGeneral{
		//ID，从参数获取
		Id: general.BaseInfo.Id,
		//姓名，从db获取
		Name:   generalInfo.Name,
		Gender: consts.Gender(generalInfo.Gender),
		//阵营，从db获取
		Group: consts.Group(generalInfo.Group),
		//标签，从db获取
		GeneralTag: buildGeneralTags(ctx, generalInfo),
		//能力值，从db获取
		AbilityAttr: buildAbilityAttr(ctx, generalInfo),
		//兵种适性，从参数获取
		ArmsAttr: buildArmsAttr(general),
		//我军/敌军，从参数获取
		GeneralBattleType: buildGeneralBattleType(teamType),
		//本局对战唯一ID，系统每次生成
		UniqueId: util.GenerateUUID(),
	}

	teamGenerals = append(teamGenerals, &vo.BattleGeneral{
		//基础信息
		BaseInfo: baseInfo,
		//战法
		EquipTactics: equipTactics,
		//兵书
		WarBooks: warbooks,
		//加点
		Addition: &vo.BattleGeneralAddition{
			//属性加点，从参数获取
			AbilityAttr: po.AbilityAttr{
				ForceBase:        cast.ToFloat64(general.Addition.AbilityAttr.ForceBase),
				IntelligenceBase: cast.ToFloat64(general.Addition.AbilityAttr.IntelligenceBase),
				CommandBase:      cast.ToFloat64(general.Addition.AbilityAttr.CommandBase),
				SpeedBase:        cast.ToFloat64(general.Addition.AbilityAttr.SpeedBase),
			},
			//武将等级，从参数获取
			GeneralLevel: consts.GeneralLevel(general.Addition.GeneralLevel),
			//武将红度，从参数获取
			GeneralStarLevel: consts.GeneralStarLevel(general.Addition.GeneralStarLevel),
		},
		//是否主将，从参数获取
		IsMaster: general.IsMaster,
		//携带兵力，从参数获取
		SoldierNum: general.SoldierNum,
		//原始兵力，从参数获取
		InitSoldierNum: general.SoldierNum,
	})
	return teamGenerals
}

func buildGeneralBattleType(teamType enum.TeamType) consts.GeneralBattleType {
	if teamType == enum.TeamType_Fighting {
		return consts.GeneralBattleType_Fighting
	} else {
		return consts.GeneralBattleType_Enemy
	}
}

// 武将标签
func buildGeneralTags(ctx context.Context, generalInfo *po.General) []consts.GeneralTag {
	generalTags := make([]consts.GeneralTag, 0)
	generalTagsArr := []string{}
	util.ParseJsonObj(ctx, &generalTagsArr, generalInfo.Tag)
	for _, tag := range generalTagsArr {
		generalTags = append(generalTags, consts.GeneralTag(cast.ToInt(tag)))
	}
	return generalTags
}

// 科技效果
func makeBuildingTechGroupAddition(team *api.BattleTeam) vo.BuildingTechGroupAddition {
	if team.BuildingTechGroupAddition == nil {
		return vo.BuildingTechGroupAddition{}
	}
	return vo.BuildingTechGroupAddition{
		GroupWeiGuoRate:   cast.ToFloat64(team.BuildingTechGroupAddition.GroupWuGuoRate),
		GroupShuGuoRate:   cast.ToFloat64(team.BuildingTechGroupAddition.GroupShuGuoRate),
		GroupWuGuoRate:    cast.ToFloat64(team.BuildingTechGroupAddition.GroupWuGuoRate),
		GroupQunXiongRate: cast.ToFloat64(team.BuildingTechGroupAddition.GroupQunXiongRate),
	}
}

// 武将标签
func makeGeneralTag(tags []consts.GeneralTag) []enum.GeneralTag {
	resList := make([]enum.GeneralTag, 0)
	for _, tag := range tags {
		resList = append(resList, enum.GeneralTag(tag))
	}
	return resList
}

// 科技属性加点
func makeBuildingTechAttrAddition(team *api.BattleTeam) vo.BuildingTechAttrAddition {
	if team.BuildingTechAttrAddition == nil {
		return vo.BuildingTechAttrAddition{}
	}

	return vo.BuildingTechAttrAddition{
		ForceAddition:        cast.ToFloat64(team.BuildingTechAttrAddition.ForceAddition),
		IntelligenceAddition: cast.ToFloat64(team.BuildingTechAttrAddition.IntelligenceAddition),
		CommandAddition:      cast.ToFloat64(team.BuildingTechAttrAddition.CommandAddition),
		SpeedAddition:        cast.ToFloat64(team.BuildingTechAttrAddition.SpeedAddition),
	}
}

// 兵种适性
func buildArmsAttr(general *api.BattleGeneral) *po.ArmsAttr {
	return &po.ArmsAttr{
		Cavalry:   consts.ArmsAbility(cast.ToString(general.BaseInfo.ArmsAttr.Cavalry)),
		Mauler:    consts.ArmsAbility(cast.ToString(general.BaseInfo.ArmsAttr.Mauler)),
		Archers:   consts.ArmsAbility(cast.ToString(general.BaseInfo.ArmsAttr.Archers)),
		Spearman:  consts.ArmsAbility(cast.ToString(general.BaseInfo.ArmsAttr.Spearman)),
		Apparatus: consts.ArmsAbility(cast.ToString(general.BaseInfo.ArmsAttr.Apparatus)),
	}
}

// 武将属性
func buildAbilityAttr(ctx context.Context, generalInfo *po.General) *po.AbilityAttr {
	attr := &po.AbilityAttrString{}
	util.ParseJsonObj(ctx, attr, generalInfo.AbilityAttr)
	return &po.AbilityAttr{
		ForceBase:        cast.ToFloat64(attr.ForceBase),
		ForceRate:        cast.ToFloat64(attr.ForceRate),
		IntelligenceBase: cast.ToFloat64(attr.IntelligenceBase),
		IntelligenceRate: cast.ToFloat64(attr.IntelligenceRate),
		CommandBase:      cast.ToFloat64(attr.CommandBase),
		CommandRate:      cast.ToFloat64(attr.CommandRate),
		SpeedBase:        cast.ToFloat64(attr.SpeedBase),
		SpeedRate:        cast.ToFloat64(attr.SpeedRate),
	}
}

func checkParam(req api.BattleDoRequest) error {
	//队伍
	if req.FightingTeam == nil {
		return errors.New("我军队伍不能为空")
	}
	if req.EnemyTeam == nil {
		return errors.New("敌军队伍不能为空")
	}
	//兵种
	if req.FightingTeam.ArmType == enum.ArmType_Unknow {
		return errors.New("我军队伍兵种不能为空")
	}
	if req.EnemyTeam.ArmType == enum.ArmType_Unknow {
		return errors.New("敌军队伍兵种不能为空")
	}
	// 武将数量
	if len(req.FightingTeam.BattleGenerals) == 0 {
		return errors.New("我军武将数量不能为空")
	}
	if len(req.EnemyTeam.BattleGenerals) == 0 {
		return errors.New("敌军武将数量不能为空")
	}
	return nil
}
